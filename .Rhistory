# --- 5) Plot: 7×7 subplots, each a 16×24 well map of r (Pearson) ---
p <- ggplot(skel, aes(x = Col_Num, y = Row_Num, fill = r)) +
geom_tile(color = "white", linewidth = tile_border_width) +
facet_grid(PlateYFacet ~ PlateXFacet, switch = "y", drop = FALSE) +
scale_fill_gradient2(
low = "blue", mid = "white", high = "red", midpoint = 0,
limits = c(-1, 1),
name = "Pearson r",
na.value = missing_fill_color
) +
scale_x_continuous(breaks = seq(1, 24, 4), expand = c(0, 0)) +
scale_y_continuous(
breaks = seq(1, 16, 2),
labels = LETTERS[seq(1, 16, 2)],
trans  = "reverse", expand = c(0, 0)
) +
labs(
title    = paste0("Well-wise Correlation Across Replicates — Site: ", site_name),
subtitle = "Each facet: Plate Y vs Plate X; tile = well (16×24). r computed over replicates (n = #reps).",
x = "Column", y = "Row"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
panel.grid = element_blank(),
strip.text = element_text(face = "bold", size = 9)
) +
coord_fixed()
# Optional console summary for quick QC
summary_pair <- corr_by_well %>%
dplyr::group_by(Plate.x, Plate.y) %>%
dplyr::summarise(
wells = dplyr::n(),
mean_r = mean(r, na.rm = TRUE),
med_r  = stats::median(r, na.rm = TRUE),
.groups = "drop"
)
cat("\n=== Well-wise correlation summary for Site:", site_name, "===\n")
print(summary_pair)
print(p)
invisible(p)
}
# ===== Run for EACH site (prints one giant 7×7×(16×24) plot per site) =====
sites_all <- sort(unique(df_parsed$Metadata_Site))
plots_wellwise <- lapply(sites_all, make_wellwise_corr_heatmap)
# ============================================================
# Well-wise correlations across replicates (per site)
# 7×7 subplots; each subplot is a 16×24 well heat map of Pearson r
# Prereqs in your script: df_parsed, plate_order_for_site, plates_per_site,
#                         rep_levels, tile_border_width, missing_fill_color
# Uses: dplyr, tidyr, ggplot2, stringr, purrr
# ============================================================
make_wellwise_corr_heatmap <- function(site_name) {
# --- 0) Choose 7 plates in your canonical order (pad with placeholders if needed) ---
p_order    <- plate_order_for_site(site_name)
sel_plates <- head(p_order, plates_per_site)
if (length(sel_plates) < plates_per_site) {
sel_plates <- c(sel_plates,
paste0("MISSING_PLATE_", seq_len(plates_per_site - length(sel_plates))))
}
# --- 1) Subset data for this site to standard wells & replicates ---
sdata <- df_parsed %>%
dplyr::filter(
Metadata_Site == site_name,
Plate %in% sel_plates,
Replicate %in% rep_levels,
Metadata_Row %in% LETTERS[1:16],
Metadata_Col >= 1, Metadata_Col <= 24
) %>%
dplyr::mutate(
Row_Num = match(Metadata_Row, LETTERS[1:16]),
Col_Num = Metadata_Col
) %>%
dplyr::select(Plate, Replicate, Row_Num, Col_Num, Metadata_Object_Count)
# --- 2) Pair plates within each (Replicate, Row, Col); suffixes use DOTS (.x/.y) ---
pairwise_wells <- sdata %>%
dplyr::rename(value = Metadata_Object_Count) %>%
dplyr::inner_join(
sdata %>% dplyr::rename(value = Metadata_Object_Count),
by = c("Replicate", "Row_Num", "Col_Num"),
suffix = c(".x", ".y")  # <-- critical: creates Plate.x and Plate.y
) %>%
# keep only the 7 selected plates on both axes (redundant but explicit)
dplyr::filter(Plate.x %in% sel_plates, Plate.y %in% sel_plates)
# --- 3) For each plate pair & well, correlate across replicates (n = #reps) ---
corr_by_well <- pairwise_wells %>%
dplyr::group_by(Plate.x, Plate.y, Row_Num, Col_Num) %>%
dplyr::summarise(
r = suppressWarnings(stats::cor(value.x, value.y, use = "pairwise.complete.obs")),
.groups = "drop"
)
# --- 4) Build a full skeleton so facets NEVER drop (forces 7×7) ---
wells_grid  <- tidyr::expand_grid(Row_Num = 1:16, Col_Num = 1:24)
plate_pairs <- tidyr::expand_grid(Plate.x = sel_plates, Plate.y = sel_plates)
skel <- tidyr::crossing(plate_pairs, wells_grid) %>%
dplyr::left_join(corr_by_well,
by = c("Plate.x", "Plate.y", "Row_Num", "Col_Num"))
# --- 5) Pretty facet labels with fixed 1..7 levels; drop = FALSE keeps 7×7 ---
px_labs <- sprintf("Plate %d\n%s", seq_len(plates_per_site), sel_plates)
py_labs <- sprintf("Plate %d\n%s", seq_len(plates_per_site), sel_plates)
skel <- skel %>%
dplyr::mutate(
PlateXFacet = factor(sprintf("Plate %d\n%s",
match(Plate.x, sel_plates), Plate.x),
levels = px_labs),
PlateYFacet = factor(sprintf("Plate %d\n%s",
match(Plate.y, sel_plates), Plate.y),
levels = py_labs)
)
# --- 6) Plot: 7×7 subplots, each a 16×24 heat map of r ---
p <- ggplot(skel, aes(x = Col_Num, y = Row_Num, fill = r)) +
geom_tile(color = "white", linewidth = tile_border_width) +
facet_grid(PlateYFacet ~ PlateXFacet, switch = "y", drop = FALSE) +
scale_fill_gradient2(
low = "blue", mid = "white", high = "red", midpoint = 0,
limits = c(-1, 1), name = "Pearson r",
na.value = missing_fill_color
) +
scale_x_continuous(breaks = seq(1, 24, 4), expand = c(0, 0)) +
scale_y_continuous(
breaks = seq(1, 16, 2), labels = LETTERS[seq(1, 16, 2)],
trans = "reverse", expand = c(0, 0)
) +
labs(
title    = paste0("Well-wise Correlation Across Replicates — Site: ", site_name),
subtitle = "Each facet: Plate Y vs Plate X. Tile = well (16×24). r over replicates.",
x = "Column", y = "Row"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
panel.grid = element_blank(),
strip.text = element_text(face = "bold", size = 9)
) +
coord_fixed()
print(p)
invisible(p)
}
# ===== Run for your sites (prints one 7×7×(16×24) plot per site) =====
sites_all <- sort(unique(df_parsed$Metadata_Site))
plots_wellwise <- lapply(sites_all, make_wellwise_corr_heatmap)
# ============================================================
# 7×7 subplots (each 16×24) for correlation-by-well, after averaging replicates
# For 4 sites (change `sites_to_plot` to pick specific ones)
# Prereqs: df_parsed, plate_order_for_site(), plates_per_site,
#          rep_levels, tile_border_width, missing_fill_color
# Libs: dplyr, tidyr, ggplot2, stringr, purrr, tibble
# ============================================================
# ---- Choose the 4 sites you want to plot ----
sites_to_plot <- sort(unique(df_parsed$Metadata_Site))[1:4]
make_contrib_corr_plot_avgrep <- function(site_name) {
# 1) Pick 7 plates in site order (pad if fewer)
p_order    <- plate_order_for_site(site_name)
sel_plates <- head(p_order, plates_per_site)
if (length(sel_plates) < plates_per_site) {
sel_plates <- c(sel_plates,
paste0("MISSING_PLATE_", seq_len(plates_per_site - length(sel_plates))))
}
# 2) Average replicates per (Plate, Row, Col) -> one value per well
avg_site <- df_parsed %>%
dplyr::filter(
Metadata_Site == site_name,
Plate %in% sel_plates,
Replicate %in% rep_levels,
Metadata_Row %in% LETTERS[1:16],
dplyr::between(Metadata_Col, 1, 24)
) %>%
dplyr::group_by(Plate, Metadata_Row, Metadata_Col) %>%
dplyr::summarise(
avg_cell_count = {
m <- mean(Metadata_Object_Count, na.rm = TRUE)
if (is.nan(m)) NA_real_ else m
},
.groups = "drop"
) %>%
dplyr::mutate(
Row_Num = match(Metadata_Row, LETTERS[1:16]),
Col_Num = Metadata_Col,
WellID  = sprintf("%s%02d", Metadata_Row, Metadata_Col)
)
# Ensure full 16×24 well grid
wells_all <- tidyr::expand_grid(Row_Num = 1:16, Col_Num = 1:24) %>%
dplyr::mutate(WellID = sprintf("%s%02d", LETTERS[Row_Num], Col_Num))
# 3) Build wells × plates table (replicate-averaged)
mat_df <- wells_all %>%
dplyr::left_join(
avg_site %>% dplyr::select(WellID, Plate, avg_cell_count),
by = "WellID"
) %>%
tidyr::pivot_wider(names_from = Plate, values_from = avg_cell_count) %>%
dplyr::select(WellID, Row_Num, Col_Num, tidyselect::any_of(sel_plates))
# If a site has <7 real plates, the extra columns won't exist; create them as NA
for (p in sel_plates) if (!p %in% colnames(mat_df)) mat_df[[p]] <- NA_real_
mat_df <- mat_df %>% dplyr::select(WellID, Row_Num, Col_Num, tidyselect::any_of(sel_plates))
# 4) Z-score across wells per-plate (so r across wells is sum(z_i * z_j)/(n-1))
X <- as.matrix(mat_df[, sel_plates, drop = FALSE])
col_means <- apply(X, 2, function(v) mean(v, na.rm = TRUE))
col_sds   <- apply(X, 2, function(v) stats::sd(v, na.rm = TRUE))
col_sds[!is.finite(col_sds) | col_sds <= 0] <- NA_real_
Z <- sweep(sweep(X, 2, col_means, "-"), 2, col_sds, "/")  # wells × plates
# 5) Exact plate×plate Pearson r across wells (for annotation)
corr_mat <- suppressWarnings(stats::cor(X, use = "pairwise.complete.obs", method = "pearson"))
# 6) Per-well contribution map for each (plate i, plate j): z_i * z_j
pair_idx <- expand.grid(i = seq_len(plates_per_site),
j = seq_len(plates_per_site),
KEEP.OUT.ATTRS = FALSE, stringsAsFactors = FALSE)
contrib_list <- lapply(seq_len(nrow(pair_idx)), function(k) {
i <- pair_idx$i[k]; j <- pair_idx$j[k]
tibble::tibble(
Row_Num = mat_df$Row_Num,
Col_Num = mat_df$Col_Num,
PlateX  = sel_plates[i],
PlateY  = sel_plates[j],
contrib = Z[, i] * Z[, j]   # per-well contribution (NA-propagating)
)
})
contrib_df <- dplyr::bind_rows(contrib_list)
# 7) Facet labels (fixed order, keep empty panels) + r annotations per facet
px_levels <- sprintf("Plate %d\n%s", seq_len(plates_per_site), sel_plates)
py_levels <- sprintf("Plate %d\n%s", seq_len(plates_per_site), sel_plates)
contrib_df <- contrib_df %>%
dplyr::mutate(
PlateXFacet = factor(sprintf("Plate %d\n%s",
match(PlateX, sel_plates), PlateX),
levels = px_levels),
PlateYFacet = factor(sprintf("Plate %d\n%s",
match(PlateY, sel_plates), PlateY),
levels = py_levels)
)
ann_df <- expand.grid(
i = seq_len(plates_per_site),
j = seq_len(plates_per_site),
KEEP.OUT.ATTRS = FALSE
) %>%
dplyr::mutate(
PlateXFacet = factor(sprintf("Plate %d\n%s", i, sel_plates[i]), levels = px_levels),
PlateYFacet = factor(sprintf("Plate %d\n%s", j, sel_plates[j]), levels = py_levels),
r = if (is.null(dim(corr_mat))) NA_real_ else corr_mat[j, i]
)
# 8) Plot: 7×7 subplots, each a 16×24 well map of z_i * z_j
p <- ggplot(contrib_df, aes(x = Col_Num, y = Row_Num, fill = contrib)) +
geom_tile(color = "white", linewidth = tile_border_width) +
facet_grid(PlateYFacet ~ PlateXFacet, switch = "y", drop = FALSE) +
scale_fill_gradient2(
low = "blue", mid = "white", high = "red", midpoint = 0,
name = "z_i × z_j",
na.value = missing_fill_color
) +
# Overlay r on each facet (top-left)
geom_text(
data = ann_df, inherit.aes = FALSE,
aes(x = 1, y = 1, label = ifelse(is.na(r), "r=NA", sprintf("r=%.2f", r))),
hjust = 0, vjust = 1, size = 3
) +
scale_x_continuous(breaks = seq(1, 24, 4), expand = c(0, 0)) +
scale_y_continuous(
breaks = seq(1, 16, 2),
labels = LETTERS[seq(1, 16, 2)],
trans  = "reverse", expand = c(0, 0)
) +
labs(
title    = paste0("Well-wise correlation contribution maps (avg over replicates) — Site: ", site_name),
subtitle = "Each facet: Plate Y vs Plate X; tile = z_i(well) × z_j(well). Facet label shows exact r.",
x = "Column", y = "Row"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
panel.grid = element_blank(),
strip.text = element_text(face = "bold", size = 9)
) +
coord_fixed()
# Console: print the 7×7 r matrix for the site
cat("\n=== Plate × Plate Pearson r across wells (avg reps) — Site:", site_name, "===\n")
print(round(corr_mat, 3))
print(p)
invisible(p)
}
# ---- Run for 4 sites (prints 4 big plots + r matrices) ----
plots_contrib <- lapply(sites_to_plot, make_contrib_corr_plot_avgrep)
# ============================================================
# Across-site, well-wise correlations (replicates averaged first)
# One figure: 7×7 subplots; each subplot is a 16×24 heat map of r
# Prereqs already in your script: df_parsed, plate_order_for_site,
#   plates_per_site (==7), rep_levels, tile_border_width, missing_fill_color
# Uses: dplyr, tidyr, ggplot2, stringr, purrr
# ============================================================
# 1) Build replicate-averaged values per (Site, PlateIndex, Well)
sites_all <- sort(unique(df_parsed$Metadata_Site))
avg_all <- lapply(sites_all, function(s) {
sel <- head(plate_order_for_site(s), plates_per_site)
# If fewer than 7 plates exist, we just use what's available; correlations will be NA where needed
df_parsed %>%
dplyr::filter(
Metadata_Site == s,
Plate %in% sel,
Replicate %in% rep_levels,
Metadata_Row %in% LETTERS[1:16],
dplyr::between(Metadata_Col, 1, 24)
) %>%
dplyr::mutate(
PlateIdx = match(Plate, sel),                 # 1..7 index within each site
Row_Num  = match(Metadata_Row, LETTERS[1:16]),
Col_Num  = Metadata_Col
) %>%
dplyr::group_by(Metadata_Site, PlateIdx, Row_Num, Col_Num) %>%
dplyr::summarise(avg_cell_count = mean(Metadata_Object_Count, na.rm = TRUE),
.groups = "drop")
}) %>% dplyr::bind_rows()
# 2) Pivot to one row per (Site, Well) with columns P1..P7 (plate indices)
wide <- avg_all %>%
tidyr::pivot_wider(
names_from  = PlateIdx,
values_from = avg_cell_count,
names_prefix = "P",
values_fill = NA_real_
)
# Ensure columns P1..P7 exist (even if some indices never appeared)
for (k in seq_len(plates_per_site)) {
nm <- paste0("P", k)
if (!nm %in% names(wide)) wide[[nm]] <- NA_real_
}
wide <- wide %>%
dplyr::select(Metadata_Site, Row_Num, Col_Num, paste0("P", 1:plates_per_site)) %>%
dplyr::arrange(Metadata_Site, Row_Num, Col_Num)
# 3) For each well (16×24), compute the 7×7 correlation across sites among P1..P7
well_corr_long <- wide %>%
dplyr::group_by(Row_Num, Col_Num) %>%
dplyr::group_modify(~{
mat <- as.matrix(dplyr::select(.x, dplyr::starts_with("P")))
# Pearson r across sites; pairwise-complete (handles NAs)
cm <- suppressWarnings(stats::cor(mat, use = "pairwise.complete.obs", method = "pearson"))
# Force dimnames P1..P7 so all 49 facets exist
colnames(cm) <- rownames(cm) <- paste0("P", 1:plates_per_site)
tibble::as_tibble(as.data.frame(as.table(cm)), .name_repair = "minimal") |>
dplyr::rename(PlateX = Var1, PlateY = Var2, r = Freq)
}) %>% dplyr::ungroup() %>%
dplyr::mutate(
PlateXIdx = as.integer(sub("^P", "", PlateX)),
PlateYIdx = as.integer(sub("^P", "", PlateY))
) %>%
dplyr::select(Row_Num, Col_Num, PlateXIdx, PlateYIdx, r)
# 4) Skeleton to guarantee full 7×7 × 16×24 layout (no facet dropping)
skel <- tidyr::crossing(
Row_Num   = 1:16,
Col_Num   = 1:24,
PlateXIdx = 1:plates_per_site,
PlateYIdx = 1:plates_per_site
)
plot_df <- skel %>%
dplyr::left_join(well_corr_long,
by = c("Row_Num","Col_Num","PlateXIdx","PlateYIdx")) %>%
dplyr::mutate(
PlateXFacet = factor(sprintf("Plate %d", PlateXIdx),
levels = sprintf("Plate %d", 1:plates_per_site)),
PlateYFacet = factor(sprintf("Plate %d", PlateYIdx),
levels = sprintf("Plate %d", 1:plates_per_site))
)
# 5) Plot: 7×7 subplots, each a 16×24 map of r (across sites; reps averaged first)
p_across_sites <- ggplot(plot_df, aes(x = Col_Num, y = Row_Num, fill = r)) +
geom_tile(color = "white", linewidth = tile_border_width) +
facet_grid(PlateYFacet ~ PlateXFacet, switch = "y", drop = FALSE) +
scale_fill_gradient2(
low = "blue", mid = "white", high = "red",
midpoint = 0, limits = c(-1, 1), name = "Pearson r",
na.value = missing_fill_color
) +
scale_x_continuous(breaks = seq(1, 24, 4), expand = c(0, 0)) +
scale_y_continuous(
breaks = seq(1, 16, 2), labels = LETTERS[seq(1, 16, 2)],
trans  = "reverse", expand = c(0, 0)
) +
labs(
title = "Across-Site Well-wise Correlation (Replicates Averaged)",
subtitle = "Each facet: Plate Y vs Plate X (indices within site). For each well, r is computed across sites.",
x = "Column", y = "Row"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
panel.grid = element_blank(),
strip.text = element_text(face = "bold", size = 9)
) +
coord_fixed()
print(p_across_sites)
# (Optional) Quick summary across all wells for each plate-pair
pair_summary <- plot_df %>%
dplyr::group_by(PlateXIdx, PlateYIdx) %>%
dplyr::summarise(
wells = dplyr::n(),
mean_r = mean(r, na.rm = TRUE),
median_r = stats::median(r, na.rm = TRUE),
.groups = "drop"
) %>% dplyr::arrange(PlateYIdx, PlateXIdx)
cat("\n=== Across-site well-wise correlation: plate-pair summary (mean/median r over 384 wells) ===\n")
print(pair_summary)
# ============================================================
# Across-site, well-wise correlations (replicates averaged first)
# One figure: 7×7 subplots; each subplot is a 16×24 heat map of r
# Prereqs already in your script: df_parsed, plate_order_for_site,
#   plates_per_site (==7), rep_levels, tile_border_width, missing_fill_color
# Uses: dplyr, tidyr, ggplot2, stringr, purrr
# ============================================================
# 1) Build replicate-averaged values per (Site, PlateIndex, Well)
sites_all <- sort(unique(df_parsed$Metadata_Site))
avg_all <- lapply(sites_all, function(s) {
sel <- head(plate_order_for_site(s), plates_per_site)
# If fewer than 7 plates exist, we just use what's available; correlations will be NA where needed
df_parsed %>%
dplyr::filter(
Metadata_Site == s,
Plate %in% sel,
Replicate %in% rep_levels,
Metadata_Row %in% LETTERS[1:16],
dplyr::between(Metadata_Col, 1, 24)
) %>%
dplyr::mutate(
PlateIdx = match(Plate, sel),                 # 1..7 index within each site
Row_Num  = match(Metadata_Row, LETTERS[1:16]),
Col_Num  = Metadata_Col
) %>%
dplyr::group_by(Metadata_Site, PlateIdx, Row_Num, Col_Num) %>%
dplyr::summarise(avg_cell_count = mean(Metadata_Object_Count, na.rm = TRUE),
.groups = "drop")
}) %>% dplyr::bind_rows()
# 2) Pivot to one row per (Site, Well) with columns P1..P7 (plate indices)
wide <- avg_all %>%
tidyr::pivot_wider(
names_from  = PlateIdx,
values_from = avg_cell_count,
names_prefix = "P",
values_fill = NA_real_
)
# Ensure columns P1..P7 exist (even if some indices never appeared)
for (k in seq_len(plates_per_site)) {
nm <- paste0("P", k)
if (!nm %in% names(wide)) wide[[nm]] <- NA_real_
}
wide <- wide %>%
dplyr::select(Metadata_Site, Row_Num, Col_Num, paste0("P", 1:plates_per_site)) %>%
dplyr::arrange(Metadata_Site, Row_Num, Col_Num)
# 3) For each well (16×24), compute the 7×7 correlation across sites among P1..P7
well_corr_long <- wide %>%
dplyr::group_by(Row_Num, Col_Num) %>%
dplyr::group_modify(~{
mat <- as.matrix(dplyr::select(.x, dplyr::starts_with("P")))
# Pearson r across sites; pairwise-complete (handles NAs)
cm <- suppressWarnings(stats::cor(mat, use = "pairwise.complete.obs", method = "pearson"))
# Force dimnames P1..P7 so all 49 facets exist
colnames(cm) <- rownames(cm) <- paste0("P", 1:plates_per_site)
tibble::as_tibble(as.data.frame(as.table(cm)), .name_repair = "minimal") |>
dplyr::rename(PlateX = Var1, PlateY = Var2, r = Freq)
}) %>% dplyr::ungroup() %>%
dplyr::mutate(
PlateXIdx = as.integer(sub("^P", "", PlateX)),
PlateYIdx = as.integer(sub("^P", "", PlateY))
) %>%
dplyr::select(Row_Num, Col_Num, PlateXIdx, PlateYIdx, r)
# 4) Skeleton to guarantee full 7×7 × 16×24 layout (no facet dropping)
skel <- tidyr::crossing(
Row_Num   = 1:16,
Col_Num   = 1:24,
PlateXIdx = 1:plates_per_site,
PlateYIdx = 1:plates_per_site
)
plot_df <- skel %>%
dplyr::left_join(well_corr_long,
by = c("Row_Num","Col_Num","PlateXIdx","PlateYIdx")) %>%
dplyr::mutate(
PlateXFacet = factor(sprintf("Plate %d", PlateXIdx),
levels = sprintf("Plate %d", 1:plates_per_site)),
PlateYFacet = factor(sprintf("Plate %d", PlateYIdx),
levels = sprintf("Plate %d", 1:plates_per_site))
)
# 5) Plot: 7×7 subplots, each a 16×24 map of r (across sites; reps averaged first)
p_across_sites <- ggplot(plot_df, aes(x = Col_Num, y = Row_Num, fill = r)) +
geom_tile(color = "white", linewidth = tile_border_width) +
facet_grid(PlateYFacet ~ PlateXFacet, switch = "y", drop = FALSE) +
scale_fill_gradient2(
low = "blue", mid = "white", high = "red",
midpoint = 0, limits = c(-1, 1), name = "Pearson r",
na.value = missing_fill_color
) +
scale_x_continuous(breaks = seq(1, 24, 4), expand = c(0, 0)) +
scale_y_continuous(
breaks = seq(1, 16, 2), labels = LETTERS[seq(1, 16, 2)],
trans  = "reverse", expand = c(0, 0)
) +
labs(
title = "Across-Site Well-wise Correlation (Replicates Averaged)",
subtitle = "Each facet: Plate Y vs Plate X (indices within site). For each well, r is computed across sites.",
x = "Column", y = "Row"
) +
theme_minimal(base_size = 12) +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
panel.grid = element_blank(),
strip.text = element_text(face = "bold", size = 9)
) +
coord_fixed()
print(p_across_sites)
# (Optional) Quick summary across all wells for each plate-pair
pair_summary <- plot_df %>%
dplyr::group_by(PlateXIdx, PlateYIdx) %>%
dplyr::summarise(
wells = dplyr::n(),
mean_r = mean(r, na.rm = TRUE),
median_r = stats::median(r, na.rm = TRUE),
.groups = "drop"
) %>% dplyr::arrange(PlateYIdx, PlateXIdx)
cat("\n=== Across-site well-wise correlation: plate-pair summary (mean/median r over 384 wells) ===\n")
print(pair_summary)
