---
title: "Project-jason"
output: html_document
date: "2025-09-09"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Data Import and Setup

```{r data-import}
# EDA - Import RDS file as dataframe
df <- readRDS("dat.rds")

# Load required packages
if (!require(dplyr)) install.packages("dplyr")
library(dplyr)
if (!require(ggplot2)) install.packages("ggplot2")
library(ggplot2)
suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(stringr); library(ggplot2); library(forcats)
})

```

## Initial Data Structure

```{r data-structure}
# Display initial structure
cat("Original dataset dimensions:", dim(df), "\n")
print(paste("Total columns:", ncol(df)))

# Identify metadata columns vs measurement columns
metadata_cols <- grep("^Metadata_", colnames(df), value = TRUE)
measurement_cols <- setdiff(colnames(df), metadata_cols)

cat("Metadata columns:", length(metadata_cols), "\n")
cat("Measurement columns:", length(measurement_cols), "\n")
```

*Insert analysis here*

## Recover the data structure

```{r missing-data-analysis}
  plates_per_site <- 7
  reps_per_site   <- 4
  rep_levels      <- paste0("R", 1:reps_per_site)
  
  site_to_plot    <- "FMP" 
  
  controls <- c("DMSO", "Nocodazole", "Tetrandrine")
  control_color_map <- c("DMSO"="green","Nocodazole"="purple","Tetrandrine"="red",
                         "Other"="grey80","Missing"="black")
  missing_fill_color <- "grey30"
  tile_border_width  <- 0.25
  
  # =========================
  # Checks
  # =========================
  stopifnot(exists("df"))
  req_cols <- c("Metadata_Site","Metadata_Row","Metadata_Col",
                "Metadata_Object_Count","Metadata_Compound_type")
  miss <- setdiff(req_cols, names(df))
  if (length(miss)) stop("Missing cols: ", paste(miss, collapse=", "))
  
  plate_col <- c("Metadata_Unique_plate","Metadata_Plate_num","Metadata_Plate",
                 "Plate","PlateID","Barcode","Metadata_Barcode")
  plate_col <- plate_col[plate_col %in% names(df)][1]
  if (is.na(plate_col)) stop("Set `plate_col` to your plate ID column.")
  
  # =========================
  # Parse Plate & Replicate from plate string
  # =========================
  df_parsed <- df %>%
    mutate(
      Metadata_Row = as.character(Metadata_Row),
      Metadata_Col = suppressWarnings(as.numeric(Metadata_Col)),
      PlateRaw     = as.character(.data[[plate_col]]),
      .rep_digit   = str_match(PlateRaw, "(?i)(?:^|[_-])R\\s*([1-4])$")[,2],
      Replicate    = ifelse(!is.na(.rep_digit), paste0("R", str_trim(.rep_digit)), NA_character_),
      Plate        = ifelse(!is.na(Replicate),
                            str_replace(PlateRaw, "(?i)[_-]R\\s*[1-4]$", ""),
                            PlateRaw)
    ) %>%
    select(-.rep_digit) %>%
    filter(!is.na(Metadata_Col), Metadata_Col>=1, Metadata_Col<=24,
           Metadata_Row %in% LETTERS[1:16])
  
  to_well_coords <- function(d) d %>% mutate(Row_Num = match(Metadata_Row, LETTERS[1:16]),
                                             Col_Num = Metadata_Col)
  
  # Plate order helper (within THIS site)
  plate_order_for_site <- function(site_name) {
    p <- df_parsed %>% filter(Metadata_Site==site_name) %>% distinct(Plate) %>% pull(Plate)
    if (!length(p)) return(character(0))
    num <- suppressWarnings(as.numeric(str_extract(p, "\\d+")))
    p[order(is.na(num), num, p)]
  }
  
  # =========================
  # Build complete **4 × 7** layout for ONE site
  # =========================
  build_site_grid <- function(site_name) {
    wells <- expand_grid(Metadata_Row=LETTERS[1:16], Metadata_Col=1:24)
    
    # pick exactly 7 plates (pad with placeholders if fewer exist)
    p_order <- plate_order_for_site(site_name)
    sel_plates <- head(p_order, plates_per_site)
    if (length(sel_plates) < plates_per_site) {
      sel_plates <- c(sel_plates,
                      paste0("MISSING_PLATE_", seq_len(plates_per_site - length(sel_plates))))
    }
    
    # skeleton: 7 plates × 4 reps × wells
    skel <- expand_grid(
      Metadata_Site = site_name,
      Plate         = sel_plates,
      Replicate     = rep_levels
    ) %>%
      crossing(wells) %>%
      to_well_coords() %>%
      mutate(
        PlateColIdx = match(Plate, sel_plates),          # columns = plates
        RepRowIdx   = match(Replicate, rep_levels),      # rows    = replicates
        PlateFacet  = factor(sprintf("Plate %d\n%s", PlateColIdx, Plate),
                             levels = sprintf("Plate %d\n%s", 1:plates_per_site, sel_plates)),
        RepFacet    = factor(sprintf("Rep %d\n%s", RepRowIdx, Replicate),
                             levels = sprintf("Rep %d\n%s", 1:reps_per_site, rep_levels))
      )
    
    # actual averages and dominant control (filtered to this site)
    dat <- df_parsed %>%
      filter(Metadata_Site==site_name) %>%
      group_by(Metadata_Site, Plate, Replicate, Metadata_Row, Metadata_Col) %>%
      summarise(avg_cell_count=mean(Metadata_Object_Count, na.rm=TRUE), .groups="drop")
    
    ctrl <- df_parsed %>%
      filter(Metadata_Site==site_name) %>%
      group_by(Metadata_Site, Plate, Replicate, Metadata_Row, Metadata_Col, Metadata_Compound_type) %>%
      summarise(n=dplyr::n(), .groups="drop") %>%
      group_by(Metadata_Site, Plate, Replicate, Metadata_Row, Metadata_Col) %>%
      slice_max(order_by=n, n=1, with_ties=FALSE) %>%
      ungroup() %>%
      mutate(control_label = ifelse(Metadata_Compound_type %in% controls,
                                    Metadata_Compound_type, "Other")) %>%
      select(Metadata_Site, Plate, Replicate, Metadata_Row, Metadata_Col, control_label)
    
    merged <- skel %>%
      left_join(dat,  by=c("Metadata_Site","Plate","Replicate","Metadata_Row","Metadata_Col")) %>%
      left_join(ctrl, by=c("Metadata_Site","Plate","Replicate","Metadata_Row","Metadata_Col"))
    
    if (!"control_label" %in% names(merged)) merged$control_label <- NA_character_
    
    merged %>%
      mutate(
        is_missing    = is.na(avg_cell_count),
        control_label = ifelse(is_missing, "Missing", control_label)
        # keep avg_cell_count = NA so fill uses `missing_fill_color`
      )
  }
  
  site_df <- build_site_grid(site_to_plot)
  

```

*Insert analysis here*

## Missing Data Count

```{r missing-data-by-type}
# =========================
# Missingness — 4 separate heat maps (one per site)
# =========================
# Prereqs assumed from your script:
# - df_parsed (from your parsing block)
# - build_site_grid(), rep_levels, plates_per_site, tile_border_width
# - libraries: dplyr, ggplot2, tidyr, stringr (already in your code)

# Pick exactly 4 sites (alphabetical); change this vector if you prefer specific ones
sites_to_plot <- sort(unique(df_parsed$Metadata_Site))[1:4]
if (length(sites_to_plot) < 4) {
  warning("Fewer than 4 sites found; plotting whatever is available.")
}

# build missing/observed status df for a site
site_missing_df <- function(site_name) {
  build_site_grid(site_name) %>%
    dplyr::mutate(
      data_status = dplyr::if_else(is_missing, "Missing", "Observed"),
      data_status = factor(data_status, levels = c("Observed", "Missing"))
    )
}


# ---- 1) Per-site numeric summary (for the 4 sites) ----
missing_summary_4 <- lapply(sites_to_plot, site_missing_df) |>
  dplyr::bind_rows() |>
  dplyr::group_by(Metadata_Site) |>
  dplyr::summarise(
    total_wells    = dplyr::n(),
    missing_wells  = sum(data_status == "Missing"),
    observed_wells = sum(data_status == "Observed"),
    missing_pct    = round(100 * mean(data_status == "Missing"), 2),
    .groups = "drop"
  ) |>
  dplyr::arrange(desc(missing_pct))

cat("\n=== Missingness Summary (Selected 4 Sites) ===\n")
print(missing_summary_4)



```

*Insert analysis here*

## Missing Data Patterns

```{r missing-data-patterns}

# make the binary RAW-style missingness heat map for a site
make_missing_plot <- function(site_name) {
  sdf <- site_missing_df(site_name)
  ggplot(sdf, aes(x = Col_Num, y = Row_Num)) +
    geom_tile(aes(fill = data_status),
              color = "grey30", linewidth = tile_border_width) +
    facet_grid(RepFacet ~ PlateFacet, switch = "y", drop = FALSE) +  # 4 × 7 layout
    scale_fill_manual(
      values = c("Observed" = "white", "Missing" = "red"),
      name   = "Data Status"
    ) +
    scale_x_continuous(breaks = seq(1, 24, 4), expand = c(0, 0)) +
    scale_y_continuous(
      breaks = seq(1, 16, 2),
      labels = LETTERS[seq(1, 16, 2)],
      trans  = "reverse", expand = c(0, 0)
    ) +
    labs(
      title    = paste0("RAW Missingness — Site: ", site_name, " (4 Replicates × 7 Plates)"),
      subtitle = "Red = Missing, White = Observed. Layout identical to RAW heat map.",
      x = "Column", y = "Row"
    ) +
    theme_minimal(base_size = 12) +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      panel.grid = element_blank(),
      strip.text = element_text(face = "bold")
    ) +
    coord_fixed()
}

# ---- 2) Four separate heat maps (print one by one) ----
plots_4 <- lapply(sites_to_plot, make_missing_plot)
for (p in plots_4) print(p)
```


## Replicate-level analysis

```{r}
# ============================================================
# Replicate-focused diagnostics for systematic errors
#   A) Residual spatial maps (rep − consensus)
#   B) RMSE heat map (4×7)
#   C) Row/Column trends per replicate
#   D) Per-plate pairwise-r heat map (6 pairs × 7 plates)
# ============================================================

.well_prep_site <- function(site_name) {
  p_order    <- plate_order_for_site(site_name)
  sel_plates <- head(p_order, plates_per_site)

  wells <- df_parsed %>%
    dplyr::filter(Metadata_Site == site_name,
                  Plate %in% sel_plates,
                  Replicate %in% rep_levels,
                  !is.na(Metadata_Row),
                  !is.na(Metadata_Col)) %>%
    dplyr::group_by(Plate, Replicate, Metadata_Row, Metadata_Col) %>%
    dplyr::summarise(value = mean(Metadata_Object_Count, na.rm = TRUE),
                     .groups = "drop") %>%
    dplyr::mutate(
      Row_Num = match(Metadata_Row, LETTERS[1:16]),
      Col_Num = as.numeric(Metadata_Col),
      PlateColIdx = match(Plate, sel_plates),
      RepRowIdx   = match(Replicate, rep_levels),

      PlateFacet = factor(sprintf("Plate %d", PlateColIdx),
                    levels = sprintf("Plate %d", 1:length(sel_plates))),

      RepFacet    = factor(sprintf("Rep %d\n%s", RepRowIdx, Replicate),
                           levels = sprintf("Rep %d\n%s", 1:length(rep_levels), rep_levels)),

      WellKey = sprintf("%s|%s%02d", Plate, Metadata_Row, Metadata_Col)
    )

  consensus <- wells %>%
    dplyr::group_by(Plate, Metadata_Row, Metadata_Col) %>%
    dplyr::summarise(cons = mean(value, na.rm = TRUE), .groups="drop")

  wells <- wells %>%
    dplyr::left_join(consensus,
                     by = c("Plate","Metadata_Row","Metadata_Col")) %>%
    dplyr::mutate(resid = value - cons)

  list(wells = wells, sel_plates = sel_plates)
}

plot_residual_maps <- function(site_name) {
  prep  <- .well_prep_site(site_name); wells <- prep$wells

  ggplot(wells, aes(x = Col_Num, y = Row_Num, fill = resid)) +
    geom_tile(color = "white", linewidth = tile_border_width) +
    facet_grid(RepFacet ~ PlateFacet, switch = "y", drop = FALSE) +
    scale_fill_gradient2(low = "blue", mid = "white", high = "red",
                         midpoint = 0, name = "Residual\n(rep − mean)") +
    # ▶ No axis numbers/ticks for columns/rows
    scale_x_continuous(expand = c(0,0), breaks = NULL) +
    scale_y_continuous(trans = "reverse", expand = c(0,0), breaks = NULL) +
    coord_fixed() +
    labs(title = paste0("Residual Spatial Maps — Site: ", site_name),
         subtitle = "Per-well residuals (replicate − across-replicate mean) reveal spatial/batch patterns",
         x = "Column", y = "Row") +
    theme_minimal(base_size = 12) +
    theme(plot.title=element_text(hjust=0.5, face="bold"),
          panel.grid=element_blank(),
          strip.text=element_text(face="bold"),
          axis.ticks = element_blank(),
          axis.text  = element_blank())
}

plot_pairwise_r_by_plate <- function(site_name) {
  prep  <- .well_prep_site(site_name); wells <- prep$wells
  plate_levels <- unique(wells$Plate)

  calc_r_for_plate <- function(df_plate) {
    wide <- df_plate %>%
      dplyr::select(WellKey, Replicate, value) %>%
      tidyr::pivot_wider(names_from = Replicate, values_from = value) %>%
      dplyr::select(tidyselect::any_of(rep_levels))
    if (ncol(wide) < 2) return(NULL)
    cm <- stats::cor(as.data.frame(wide), use="pairwise.complete.obs", method="pearson")
    pairs <- combn(colnames(cm), 2, simplify = FALSE)
    dplyr::bind_rows(lapply(pairs, function(pr) {
      data.frame(pair = paste(pr, collapse="–"), r = cm[pr[1], pr[2]])
    }))
  }

  r_by_plate <- wells %>%
    dplyr::group_by(Plate) %>%
    dplyr::group_modify(~ calc_r_for_plate(.x)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(PlateColIdx = match(Plate, plate_levels),
                  pair = factor(pair,
                                levels = c("R1–R2","R1–R3","R1–R4",
                                           "R2–R3","R2–R4","R3–R4")))

  ggplot(r_by_plate, aes(x = PlateColIdx, y = pair, fill = r)) +
    geom_tile(color = "grey30", linewidth = 0.25) +
    geom_text(aes(label = sprintf("%.2f", r)), size = 3) +
    scale_fill_gradient2(low="blue", mid="white", high="red",
                         limits=c(-1,1), midpoint=0, name="Pearson r") +
    scale_x_continuous(breaks = unique(r_by_plate$PlateColIdx),
                   labels = sprintf("Plate %d", unique(r_by_plate$PlateColIdx)),
                   expand = c(0,0))+

    labs(title = paste0("Pairwise Replicate r by Plate — Site: ", site_name),
         x = NULL, y = "Replicate pair") +
    theme_minimal(base_size = 12) +
    theme(panel.grid = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold"))
}


sites_to_check <- sort(unique(df_parsed$Metadata_Site))[1:4]

for (st in sites_to_check) {
  print(plot_residual_maps(st))      # A
  print(plot_pairwise_r_by_plate(st))# D
}

library(patchwork)



sites_to_check <- sort(unique(df_parsed$Metadata_Site))[1:4]

# helper: keep only subtitle (site name), remove legend and other redundant stuff
make_site_plot <- function(st, plot_fun) {
  plot_fun(st) +
    labs(title = NULL, x = NULL, y = NULL, subtitle = st) +
    theme(
      # remove everything axis-related
      axis.title    = element_blank(),
      axis.text     = element_blank(),
      axis.ticks    = element_blank(),
      axis.line     = element_blank(),
      panel.grid    = element_blank(),

      # remove legends
      legend.position = "none",

      # remove facet strip labels & their backgrounds
      strip.text       = element_blank(),
      strip.background = element_blank(),

      # keep site name as centered, bold subtitle
      plot.title    = element_blank(),
      plot.subtitle = element_text(hjust = 0.5, face = "bold"),

      # optional: tighten spacing a bit since strips are gone
      panel.spacing = unit(4, "pt"),
      plot.margin   = margin(2, 2, 2, 2, "pt")
    )
}



# build site plots
resid_plots <- lapply(sites_to_check, function(st) make_site_plot(st, plot_residual_maps))
r_plots     <- lapply(sites_to_check, function(st) make_site_plot(st, plot_pairwise_r_by_plate))

# arrange 2x2 grids
resid_grid <- (resid_plots[[1]] | resid_plots[[2]]) /
              (resid_plots[[3]] | resid_plots[[4]])

r_grid <- (r_plots[[1]] | r_plots[[2]]) /
          (r_plots[[3]] | r_plots[[4]])

# add only one global title
resid_grid <- resid_grid + plot_annotation(title = "Residual Spatial Maps — All Sites")
r_grid     <- r_grid     + plot_annotation(title = "Pairwise Replicate r by Plate — All Sites")

# print only two plots total
print(resid_grid)
print(r_grid)

```

## Swap Plate 1 and 7 in Site IMTM
```{r}
# =========================
# 1) Helper: plate order from a given data frame
# =========================
plate_order_for_site_df <- function(d, site_name) {
  p <- d %>% dplyr::filter(Metadata_Site == site_name) %>%
    dplyr::distinct(Plate) %>% dplyr::pull(Plate)
  if (!length(p)) return(character(0))
  num <- suppressWarnings(stringr::str_extract(p, "\\d+") %>% as.numeric())
  p[order(is.na(num), num, p)]
}

# =========================
# 2) Swap Plate 1 <-> Plate 7 in R4 for a site (non-destructive)
# =========================
swap_R4_plate1_7 <- function(d, site_name) {
  sel <- head(plate_order_for_site_df(d, site_name), plates_per_site)
  stopifnot(length(sel) >= 7)            # ensure 7 plates exist
  p1 <- sel[1]; p7 <- sel[7]

  d %>%
    dplyr::mutate(
      Plate = dplyr::case_when(
        Metadata_Site == site_name & Replicate == "R4" & Plate == p1 ~ p7,
        Metadata_Site == site_name & Replicate == "R4" & Plate == p7 ~ p1,
        TRUE ~ Plate
      )
    )
}

# =========================
# 3) Analysis: pairwise replicate r by plate (well-wise)
# =========================
pairwise_r_by_plate_plot <- function(d, site_name, tile_border_width = 0.25) {
  sel <- head(plate_order_for_site_df(d, site_name), plates_per_site)

  # well-wise table
  wells <- d %>%
    dplyr::filter(Metadata_Site == site_name,
                  Plate %in% sel,
                  Replicate %in% rep_levels) %>%
    dplyr::group_by(Plate, Metadata_Row, Metadata_Col, Replicate) %>%
    dplyr::summarise(v = mean(Metadata_Object_Count, na.rm = TRUE), .groups="drop")

  # per-plate replicate correlations
  calc_r_for_plate <- function(df_plate) {
    wide <- df_plate %>%
      tidyr::pivot_wider(names_from = Replicate, values_from = v) %>%
      dplyr::select(tidyselect::any_of(rep_levels))
    if (ncol(wide) < 2) return(NULL)
    cm <- stats::cor(as.data.frame(wide), use = "pairwise.complete.obs")
    pairs <- combn(colnames(cm), 2, simplify = FALSE)
    dplyr::bind_rows(lapply(pairs, function(pr) {
      data.frame(pair = paste(pr, collapse = "–"), r = cm[pr[1], pr[2]])
    }))
  }

  r_by_plate <- wells %>%
    dplyr::group_by(Plate) %>%
    dplyr::group_modify(~ calc_r_for_plate(.x)) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(
      Plate = factor(Plate, levels = sel),
      PlateColIdx = as.integer(Plate),
      pair = factor(pair,
                    levels = c("R1–R2","R1–R3","R1–R4",
                               "R2–R3","R2–R4","R3–R4"))
    )

  ggplot(r_by_plate, aes(x = PlateColIdx, y = pair, fill = r)) +
    geom_tile(color = "grey30", linewidth = tile_border_width) +
    geom_text(aes(label = sprintf("%.2f", r)), size = 3) +
    scale_fill_gradient2(low = "blue", mid = "white", high = "red",
                         limits = c(-1,1), midpoint = 0, name = "Pearson r") +
    scale_x_continuous(
      breaks = seq_along(sel),
      labels = sprintf("Plate%d", seq_along(sel)),
      expand = c(0,0)
      
    ) +
    labs(title = paste0("Pairwise Replicate r by Plate — Site: ", site_name,"(Swapped)"),
         x = NULL, y = "Replicate pair") +
    theme_minimal(base_size = 12) +
    theme(panel.grid = element_blank(),
          plot.title = element_text(hjust = 0.5, face = "bold"))
}

# =========================
# 4) Do the swap for a site and re-plot (before/after)
# =========================
site_swap <- "IMTM"   # <-- change if needed

# Before
p_before <- pairwise_r_by_plate_plot(df_parsed, site_swap)
print(p_before)

# Swap
df_parsed_swapped <- swap_R4_plate1_7(df_parsed, site_swap)

# After
p_after  <- pairwise_r_by_plate_plot(df_parsed_swapped, site_swap)
print(p_after)
```




```{r}
# ==========================================
# DMSO boxplots by plate — 4 sites × 4 replicates
# ==========================================

d <- if (exists("df_parsed_swapped")) df_parsed_swapped else df_parsed
sites_to_plot <- intersect(c("FMP","IMTM","MEDINA","USC"),
                           sort(unique(d$Metadata_Site)))[1:4]

# helper: numeric-aware plate order for this data frame
plate_order_for_site_df <- function(dd, site) {
  p <- dd %>% dplyr::filter(Metadata_Site == site) %>% dplyr::distinct(Plate) %>% dplyr::pull(Plate)
  if (!length(p)) return(character(0))
  num <- suppressWarnings(stringr::str_extract(p, "\\d+") %>% as.numeric())
  p[order(is.na(num), num, p)]
}

# helper: DMSO well keys per site using dominant label per well
dmso_well_keys <- function(dd, site) {
  sel <- head(plate_order_for_site_df(dd, site), plates_per_site)
  dd %>%
    dplyr::filter(Metadata_Site == site, Plate %in% sel) %>%
    dplyr::group_by(Plate, Metadata_Row, Metadata_Col, Metadata_Compound_type) %>%
    dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
    dplyr::group_by(Plate, Metadata_Row, Metadata_Col) %>%
    dplyr::slice_max(order_by = n, n = 1, with_ties = FALSE) %>%
    dplyr::ungroup() %>%
    dplyr::filter(Metadata_Compound_type == "DMSO") %>%
    dplyr::mutate(WellKey = sprintf("%s|%s%02d", Plate, Metadata_Row, as.integer(Metadata_Col))) %>%
    dplyr::select(Plate, WellKey)
}
# --- unchanged helpers above (plate_order_for_site_df, dmso_well_keys, dmso_site_long) ---
# Just add PlateIdx inside dmso_site_long and use it in the plot.

dmso_site_long <- function(dd, site) {
  sel  <- head(plate_order_for_site_df(dd, site), plates_per_site)
  keys <- dmso_well_keys(dd, site)

  dd %>%
    dplyr::filter(Metadata_Site == site,
                  Plate %in% sel,
                  Replicate %in% rep_levels) %>%
    dplyr::mutate(Metadata_Row = as.character(Metadata_Row),
                  Metadata_Col = as.integer(Metadata_Col)) %>%
    dplyr::group_by(Replicate, Plate, Metadata_Row, Metadata_Col) %>%
    dplyr::summarise(value = mean(Metadata_Object_Count, na.rm = TRUE), .groups = "drop") %>%
    dplyr::mutate(WellKey = sprintf("%s|%s%02d", Plate, Metadata_Row, Metadata_Col)) %>%
    dplyr::inner_join(keys, by = c("Plate","WellKey")) %>%
    dplyr::mutate(
      Plate      = factor(Plate, levels = sel),
      PlateIdx   = match(Plate, sel),                # <-- plate number 1..7
      Replicate  = factor(Replicate, levels = rep_levels)
    )
}

plot_dmso_box_site <- function(dd, site) {
  df <- dmso_site_long(dd, site)

  ggplot(df, aes(x = factor(PlateIdx, levels = 1:plates_per_site), y = value)) +
    geom_boxplot(outlier.alpha = 0.5, fill = "grey92", color = "grey35") +
    geom_jitter(width = 0.15, alpha = 0.25, size = 0.6) +
    facet_wrap(~ Replicate, ncol = 2) +
    scale_x_discrete(drop = FALSE, labels = as.character(1:plates_per_site)) +  # <-- numbers
    labs(
      title = paste0("DMSO control — Boxplots by Plate (Site: ", site, ")"),
      subtitle = "x-axis shows plate number (1–7); one panel per replicate",
      x = "Plate #", y = "Cell count"
    ) +
    theme_minimal(base_size = 12) +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5, face = "bold"),
      panel.grid.major.x = element_blank()
    )
}

# produce the four figures (one per site)
d <- if (exists("df_parsed_swapped")) df_parsed_swapped else df_parsed
sites_to_plot <- intersect(c("FMP","IMTM","MEDINA","USC"),
                           sort(unique(d$Metadata_Site)))[1:4]
for (st in sites_to_plot) print(plot_dmso_box_site(d, st))

```
```{r}
# ==========================================
# Location-effect boxplots (NON-CONTROLS ONLY)
# 4 figures (one per site), each has 4 subplots (R1–R4)
# Boxplots are by column (1–24), pooled across plates,
# using robust z within Plate×Replicate to remove plate offsets.
# ==========================================

d <- if (exists("df_parsed_swapped")) df_parsed_swapped else df_parsed
sites_to_plot <- intersect(c("FMP","IMTM","MEDINA","USC"),
                           sort(unique(d$Metadata_Site)))[1:4]

# --- helper: numeric-aware plate order for a given data frame
plate_order_for_site_df <- function(dd, site) {
  p <- dd %>% dplyr::filter(Metadata_Site == site) %>% dplyr::distinct(Plate) %>% dplyr::pull(Plate)
  if (!length(p)) return(character(0))
  num <- suppressWarnings(stringr::str_extract(p, "\\d+") %>% as.numeric())
  p[order(is.na(num), num, p)]
}

# --- helper: keep wells whose dominant label is NOT a control
noncontrol_well_keys_for_site <- function(dd, site) {
  sel <- head(plate_order_for_site_df(dd, site), plates_per_site)
  dd %>%
    dplyr::filter(Metadata_Site == site, Plate %in% sel) %>%
    dplyr::group_by(Plate, Metadata_Row, Metadata_Col, Metadata_Compound_type) %>%
    dplyr::summarise(n = dplyr::n(), .groups = "drop") %>%
    dplyr::group_by(Plate, Metadata_Row, Metadata_Col) %>%
    dplyr::slice_max(order_by = n, n = 1, with_ties = FALSE) %>%
    dplyr::ungroup() %>%
    dplyr::filter(!(Metadata_Compound_type %in% controls)) %>%   # exclude controls
    dplyr::mutate(WellKey = sprintf("%s|%s%02d", Plate, Metadata_Row, as.integer(Metadata_Col))) %>%
    dplyr::select(Plate, WellKey)
}

# --- build tidy NON-CONTROL well data for a site
build_location_df <- function(dd, site) {
  sel  <- head(plate_order_for_site_df(dd, site), plates_per_site)
  keys <- noncontrol_well_keys_for_site(dd, site)

  df <- dd %>%
    dplyr::filter(Metadata_Site == site,
                  Plate %in% sel,
                  Replicate %in% rep_levels) %>%
    dplyr::mutate(Metadata_Row = as.character(Metadata_Row),
                  Metadata_Col = as.integer(Metadata_Col)) %>%
    dplyr::group_by(Replicate, Plate, Metadata_Row, Metadata_Col) %>%
    dplyr::summarise(value = mean(Metadata_Object_Count, na.rm = TRUE), .groups = "drop") %>%
    dplyr::mutate(WellKey = sprintf("%s|%s%02d", Plate, Metadata_Row, Metadata_Col)) %>%
    dplyr::inner_join(keys, by = c("Plate","WellKey")) %>%      # keep NON-controls
    dplyr::mutate(
      Plate     = factor(Plate, levels = sel),
      Replicate = factor(Replicate, levels = rep_levels),
      Col_Num   = Metadata_Col,
      Row_Ltr   = Metadata_Row
    )

  # Robust within-plate×replicate normalization to isolate location effects
  df %>%
    dplyr::group_by(Plate, Replicate) %>%
    dplyr::mutate(
      med = stats::median(value, na.rm = TRUE),
      mad = stats::mad(value, center = med, constant = 1.4826, na.rm = TRUE),
      value_norm = dplyr::if_else(is.finite(mad) & mad > 0, (value - med)/mad, value - med)
    ) %>%
    dplyr::ungroup()
}

# --- plot: by COLUMN (1–24) with facets for R1–R4
plot_location_box_by_col <- function(df_loc, site) {
  ggplot(df_loc, aes(x = factor(Col_Num, levels = 1:24), y = value_norm)) +
    geom_boxplot(outlier.alpha = 0.35, fill = "grey92", color = "grey35") +
    geom_jitter(width = 0.15, alpha = 0.15, size = 0.5) +
    facet_wrap(~ Replicate, ncol = 2) +
    scale_x_discrete(drop = FALSE) +
    labs(
      title = paste0("Location Effect (Columns) — Non-controls — Site: ", site),
      subtitle = "Robust z within Plate×Replicate; higher spread/shift at specific columns suggests location bias",
      x = "Column (1–24)",
      y = "Robust z (within Plate×Replicate)"
    ) +
    theme_minimal(base_size = 12) +
    theme(
      strip.text = element_text(face = "bold"),
      plot.title = element_text(hjust = 0.5, face = "bold"),
      panel.grid.major.x = element_blank()
    )
}

# ---- produce the four figures (one per site)
for (st in sites_to_plot) {
  df_loc <- build_location_df(d, st)
  print(plot_location_box_by_col(df_loc, st))
}
```
